코드 스플리팅
=

리액트를 실제로 배포한다면 build 작업을 거쳐야한다.  
빌드작업을 통하여 프로젝트에서 사용하는 자바스크립트 파일 안에서 불필요한 주석, 경고메시지, 공백등을 제거하여 파일사이즈를 최소화 하기도 하고 정적파일들에 대한 경로지정도 이루어져야 한다.  

이작업은 웹팩(webpack)이 담당하고 있으며, 웹팩의 가장 기본적 설정으로는 자바스크립트 파일은 하나로, CSS또한 하나의 파일로 합쳐지게 된다. 하지만 CRA의 경우 웹팩 v4의 SplitChunks 기능이 적용되어 파일사이즈가 일정 이상이 되거나, 다른 모듈에서 호출하는 횟수가 일정이상이 되면 파일을 따로 분리시켜 캐싱효과를 일으킨다.  

파일의 이름에는 해시(hash)값이 포함되며 이 값은 빌드를 하게 되는 과정에서 해당 파일의 실제 내용이 바뀌지 않는다면 이 해쉬값도 바뀌지 않는다. 이를 통해 브라우저가 특정 페이지에 재방문 하게 될 때 자바스크립트 파일이 같은 경우 기존에 받아놓았던 파일을 사용 할 수 있기에 캐싱의 이점을 더욱 누릴 수 있다.  

이러한 SplitChunk 코드 스플리팅은 단순히 효율적인 캐싱효과만 있을 뿐이다. 만약 A,B,C로 이루어진 SPA를 개발한다고 가정한다면, 사용자가  A페이지를 방문하였을때, B페이지와 C 페이지에서 사용하고 있는 컴포넌트에 대한 정보는 필요가 없게된다. 하지만 별도의 설정을 하지 않는다면, A,B,C모두 하나의 파일에 저장이 된다. 앱의 규모가 커지게된다면 파일사이즈가 너무 커져버려 유저경험, 트래픽량도 비효율적이게 된다.  

이러한 문제점을 해결하기 위해 컴포넌트 비동기로딩을 한다. 코드스플리팅은 컴포넌트의 형태가 아니여도 상관없다. 자바스크립트 함수나 객체 또한 코드스플리팅이 가능하다. 이러한 코드스플리팅을 통해 우리는 사전에 정한 특정 코드들을 다른 파일로 저장하여, 실제로 필요하게 될 때 불러와서 사용이 가능해진다.  
 
JS파일의 비동기 로딩
-
```
export default function splitAlarm(){
    alert("알람!");
}
```

```
    import('./splitAlarm').then(result => {
        result.default();
    })
```

default로 export한 것을 import 한 후 result.default를 통해 호출가능


React.lazy와 Suspense를 통한 컴포넌트 비동기 렌더링
-
React.lazy와 Suspense는 리액트에 내장되어있는 코드스플리팅을 위한 유틸함수 및 컴포넌트, v16.6에서부터 도입되었으며 서버사이드 랜더링을 하게 된 경우는 아직까지는 react-loadable을 사용하는 것을 추천한다.  

React.lazy의 역활은 우리가 구현한 withSplitting과 유사하다. 그리고 Suspense는 리액트에 내장되어있는 컴포넌트이며, 이를 통해 코드스플리팅 동안 임의로 보여줄 JSX를 설정 할 수 있게 된다.  

React.lazy
```
const SplitMe = React.lazy(() => import('./SplitMe'));
```
Suspense
```
import React, {Suspense, Component} from 'react';

<Suspense fallback ={<div>로딩중입니다만..</div>}>
    <SplieMe/>
</Suspense>
```

